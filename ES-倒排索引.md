# ES-倒排索引

## 简介

在数据生成的时候，通过使用分词器，将文档拆分成多个词语，将词语对应的文档id(并非用户指定的文档id，而是lucene使用的内部id)保存下来。这种反过来的索引，就是倒排索引(inverted index)。

## 说明

简单的倒排索引是完全不够的，因为世界上有无数个词语，每次查询都全局遍历显然是不合理的，于是Lucene提出来Term index、Term dictionary和Posting list。

### Term index

使用FST算法，实现了存储在内存中的一个类似字典树，用于快速指向具体的词语。

### Term dictionary

存储了所有的词语以及和对应的Posting list的关系。在这里，同样前缀的词语会存储在一起，并将前缀提取出来，因此存储需要的大小比B数小。

用于快速判断一个词语(term)是否存在。

### Posting list

存储对应词语对应的文档id的列表。

#### 压缩存储

对于一个segment中的每个term，都有一个列表来记录文档id(其实还有别的东西)，为了节省存储空间，es(lucene)做了如下的操作：

1. 整形压缩，正常情况下，一个整形需要4字节来存储；但是将整形转化为二进制位，获取列表中最大的id，每个id只保存最大的id需要的位数即可。
2. 每128个文档都会走一次第一步的压缩，生成一个block。
3. 还有个VIntBlock方法，但是没看明白，不足128的部分就由这个算法生成block。
4. 在压缩后，会有一个跳表结构来高速查询到指定的block
5. 举个例子，某个term在259个文档中出现，就会生成2 + 3个block，由这5个block组成一个跳表
6. 通常情况下，会存储文档的id，为了节省空间，由于文档id是递增的，实际存储的是文档之间的差值。

#### 高效交集

当有多个查询条件时，需要将多个条件查询出来的文档id取交集，es(lucene)做了如下的操作:

1. 将文档列表转化为位图，多个位图直接求交集；有较大的限制，比如[0, 65535]，总不能创建一个65536长的bit数组吧
2. Roaring Bitmaps，将32位的整数切分成高16位和低16位，将高16位作为整数，低16位作为位图，排序后作为有序数组+位图的形式来节省空间；排序是为了查询时支持二分查询。
3. 链表合并，双指针，或者跳表+双指针。